#include <cuda_runtime.h>
#include <cuda_fp16.h>
#include <cublas_v2.h>
#include <iostream>

#define HIDDEN_SIZE 4096
#define INTERMEDIATE_SIZE 12288

#define CHECK_CUDA(call) \
    do { \
        cudaError_t err = call; \
        if (err != cudaSuccess) { \
            std::cerr << "CUDA error at " << __FILE__ << ":" << __LINE__ << " - " \
                      << cudaGetErrorString(err) << std::endl; \
            exit(1); \
        } \
    } while (0)

#define CHECK_CUBLAS(call) \
    do { \
        cublasStatus_t err = call; \
        if (err != CUBLAS_STATUS_SUCCESS) { \
            std::cerr << "cuBLAS error at " << __FILE__ << ":" << __LINE__ << " - " \
                      << "status " << err << std::endl; \
            exit(1); \
        } \
    } while (0)

// Fast GELU: polynomial tanh approx
__device__ __forceinline__ float fast_gelu(float x) {
    float x3 = x * x * x;
    float z = 0.79788456f * (x + 0.044715f * x3);
    float z2 = z * z;
    return 0.5f * x * (1.0f + z * (27.0f + z2) / (27.0f + 9.0f * z2));
}

// GEGLU on interleaved UV (lda=2*INTER). Writes gelu(U)*V in-place over V.
__global__ void geglu_kernel(half2* __restrict__ UV, int B) {
    const int h2sec = INTERMEDIATE_SIZE / 2;
    const int h2col = INTERMEDIATE_SIZE;

    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= B * h2sec) return;

    int b = idx / h2sec;
    int k = idx % h2sec;

    size_t u = (size_t)b * h2col + k;
    size_t v = u + h2sec;

    float2 uf = __half22float2(__ldg(&UV[u]));
    float2 vf = __half22float2(__ldg(&UV[v]));

    UV[v] = __floats2half2_rn(fast_gelu(uf.x) * vf.x, fast_gelu(uf.y) * vf.y);
}

void geglu_ffn(
    cublasHandle_t handle,
    const __half* x, const __half* Wuv, const __half* Wo,
    __half* UV, __half* output, int B)
{
    static bool once = false;
    if (!once) { cublasSetMathMode(handle, CUBLAS_TENSOR_OP_MATH); once = true; }

    const __half one = __float2half(1.0f), zero = __float2half(0.0f);

    // GEMM 1: Wuv * x -> UV
    cublasHgemm(handle, 
        CUBLAS_OP_N, 
        CUBLAS_OP_N,
        2 * INTERMEDIATE_SIZE, 
        B, 
        HIDDEN_SIZE,
        &one, 
        Wuv, 
        2 * INTERMEDIATE_SIZE, x, HIDDEN_SIZE, 
        &zero, UV, 2 * INTERMEDIATE_SIZE); 

    int n = B * (INTERMEDIATE_SIZE / 2);
    geglu_kernel<<<(n + 255) / 256, 256>>>((half2*)UV, B);

    // GEMM 2: Wo * V -> output 
    cublasHgemm(handle, 
        CUBLAS_OP_N, 
        CUBLAS_OP_N,
        HIDDEN_SIZE, 
        B, 
        INTERMEDIATE_SIZE,
        &one, 
        Wo, 
        HIDDEN_SIZE, 
        UV + INTERMEDIATE_SIZE, 
        2 * INTERMEDIATE_SIZE,
        &zero, 
        output, 
        HIDDEN_SIZE);
}